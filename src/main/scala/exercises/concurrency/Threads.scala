/*
 * This Scala source file was generated by the Gradle 'init' task.
 */
package exercises.concurrency

object Utils {
  def thread(body: => Unit): Thread = {
    val t = new Thread{
      override def run(): Unit = body
    }
    t.start()
    t
  }

  def measureTime[T](body: => T): T = {
    val start = System.nanoTime()
    val res = body
    val took = System.nanoTime() - start;
    println("Took " + java.util.concurrent.TimeUnit.NANOSECONDS.toMillis(took) + "ms")
    res
  }
}

import java.util.concurrent.TimeUnit

import Utils._

object RaceConds extends App {
  var k = 0
  def incAndReturn = { k+=1; k }
  measureTime {
    val t = thread {
      for (i <- 1 to 10000000) incAndReturn
    }
    for (i <- 1 to 10000000) incAndReturn
    t.join()
  }
  println(k)
}

object AvoidRaceConds extends App {
  var k = 0
  def incAndReturn = this.synchronized { k+=1; k }
  measureTime {
    val t = thread {
      for (i <- 1 to 10000000) incAndReturn
    }
    for (i <- 1 to 10000000) incAndReturn
    t.join()
  }
  println(k)
}

object ReorderingBug extends App {
  for (i <- 0 until 100000) {
    var a = false; var b = false; var x = -1; var y = -1
    val t1 = thread { a = true; y = if (b) 0 else 1 }
    val t2 = thread { b = true; x = if (a) 0 else 1 }
    t1.join(); t2.join()
    assert(!(x == 1 && y == 1), s"x = $x, y = $y")
  }
}

object ReorderingBugFixed extends App {
  for (i <- 0 until 100000) {
    var a = false; var b = false; var x = -1; var y = -1
    val t1 = thread { this.synchronized{ a = true }; y = if (b) 0 else 1 }
    val t2 = thread { this.synchronized{ b = true }; x = if (a) 0 else 1 }
    t1.join(); t2.join()
    assert(!(x == 1 && y == 1), s"x = $x, y = $y")
  }
}
