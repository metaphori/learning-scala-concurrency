/*
 * This Scala source file was generated by the Gradle 'init' task.
 */
package exercises.concurrency

object Utils {
  def thread(body: => Unit): Thread = {
    val t = new Thread{
      override def run(): Unit = body
    }
    t.start()
    t
  }

  def measureTime[T](body: => T): T = {
    val start = System.nanoTime()
    val res = body
    val took = System.nanoTime() - start;
    println("Took " + java.util.concurrent.TimeUnit.NANOSECONDS.toMillis(took) + "ms")
    res
  }
}

import java.util.concurrent.TimeUnit

import Utils._

object RaceConds extends App {
  var k = 0
  def incAndReturn = { k+=1; k }
  measureTime {
    val t = thread {
      for (i <- 1 to 10000000) incAndReturn
    }
    for (i <- 1 to 10000000) incAndReturn
    t.join()
  }
  println(k)
}

object AvoidRaceConds extends App {
  var k = 0
  def incAndReturn = this.synchronized { k+=1; k }
  measureTime {
    val t = thread {
      for (i <- 1 to 10000000) incAndReturn
    }
    for (i <- 1 to 10000000) incAndReturn
    t.join()
  }
  println(k)
}

object ReorderingBug extends App {
  for (i <- 0 until 100000) {
    var a = false; var b = false; var x = -1; var y = -1
    val t1 = thread { a = true; y = if (b) 0 else 1 }
    val t2 = thread { b = true; x = if (a) 0 else 1 }
    t1.join(); t2.join()
    assert(!(x == 1 && y == 1), s"x = $x, y = $y")
  }
}

object ReorderingBugFixed extends App {
  for (i <- 0 until 100000) {
    var a = false; var b = false; var x = -1; var y = -1
    val t1 = thread { this.synchronized{ a = true }; y = if (b) 0 else 1 }
    val t2 = thread { this.synchronized{ b = true }; x = if (a) 0 else 1 }
    t1.join(); t2.join()
    assert(!(x == 1 && y == 1), s"x = $x, y = $y")
  }
}

class BoxBad(init: Int = 0){
  var i = init
  def moveInto(b2: BoxBad) = this.synchronized { b2.synchronized{ b2.i += i; i -= i; } }
}

class BoxOk(init: Int = 0){
  var i = init
  def moveInto(b2: BoxOk) =
    if(this.hashCode()>b2.hashCode()) { this.synchronized { b2.synchronized{ b2.i += i; i -= i; } } }
    else { b2.synchronized { this.synchronized{ b2.i += i; i -= i; } } }
}

object Deadlock extends App {
  val b1 = new BoxBad(50); val b2 = new BoxBad(100)
  val t1 = thread { for(i <- 1 to 10000){ b1.moveInto(b2) } }
  val t2 = thread { for(i <- 1 to 10000){ b2.moveInto(b1) } }
  t1.join(); t2.join();
  println(s"b1 = ${b1.i}; b2 = ${b2.i}")
}

object DeadlockSolved extends App {
  val b1 = new BoxOk(50); val b2 = new BoxOk(100)
  val t1 = thread { for(i <- 1 to 10000){ b1.moveInto(b2) } }
  val t2 = thread { for(i <- 1 to 10000){ b2.moveInto(b1) } }
  t1.join(); t2.join();
  println(s"b1 = ${b1.i}; b2 = ${b2.i}") // But notice that result depends on ordering
}