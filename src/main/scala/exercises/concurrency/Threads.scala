/*
 * This Scala source file was generated by the Gradle 'init' task.
 */
package exercises.concurrency

object Utils {
  def thread(body: => Unit): Thread = {
    val t = new Thread{
      override def run(): Unit = body
    }
    t.start()
    t
  }

  def measureTime[T](body: => T): T = {
    val start = System.nanoTime()
    val res = body
    val took = System.nanoTime() - start;
    println("Took " + java.util.concurrent.TimeUnit.NANOSECONDS.toMillis(took) + "ms")
    res
  }
}

import java.util.concurrent.TimeUnit

import Utils._
import exercises.concurrency.SynchronizedPoolOk.tasks

object RaceConds extends App {
  var k = 0
  def incAndReturn = { k+=1; k }
  measureTime {
    val t = thread {
      for (i <- 1 to 10000000) incAndReturn
    }
    for (i <- 1 to 10000000) incAndReturn
    t.join()
  }
  println(k)
}

object AvoidRaceConds extends App {
  var k = 0
  def incAndReturn = this.synchronized { k+=1; k }
  measureTime {
    val t = thread {
      for (i <- 1 to 10000000) incAndReturn
    }
    for (i <- 1 to 10000000) incAndReturn
    t.join()
  }
  println(k)
}

object ReorderingBug extends App {
  for (i <- 0 until 100000) {
    var a = false; var b = false; var x = -1; var y = -1
    val t1 = thread { a = true; y = if (b) 0 else 1 }
    val t2 = thread { b = true; x = if (a) 0 else 1 }
    t1.join(); t2.join()
    assert(!(x == 1 && y == 1), s"x = $x, y = $y")
  }
}

object ReorderingBugFixed extends App {
  for (i <- 0 until 100000) {
    var a = false; var b = false; var x = -1; var y = -1
    val t1 = thread { this.synchronized{ a = true }; y = if (b) 0 else 1 }
    val t2 = thread { this.synchronized{ b = true }; x = if (a) 0 else 1 }
    t1.join(); t2.join()
    assert(!(x == 1 && y == 1), s"x = $x, y = $y")
  }
}

object ReorderingBugFixed2 extends App {
  for (i <- 0 until 100000) {
    @volatile var a = false; @volatile var b = false; var x = -1; var y = -1
    val t1 = thread { a = true; y = if (b) 0 else 1 }
    val t2 = thread { b = true; x = if (a) 0 else 1 }
    t1.join(); t2.join()
    assert(!(x == 1 && y == 1), s"x = $x, y = $y")
  }
}

class BoxBad(init: Int = 0){
  var i = init
  def moveInto(b2: BoxBad) = this.synchronized { b2.synchronized{ b2.i += i; i -= i; } }
}

class BoxOk(init: Int = 0){
  var i = init
  def moveInto(b2: BoxOk) =
    if(this.hashCode()>b2.hashCode()) { this.synchronized { b2.synchronized{ b2.i += i; i -= i; } } }
    else { b2.synchronized { this.synchronized{ b2.i += i; i -= i; } } }
}

object Deadlock extends App {
  val b1 = new BoxBad(50); val b2 = new BoxBad(100)
  val t1 = thread { for(i <- 1 to 10000){ b1.moveInto(b2) } }
  val t2 = thread { for(i <- 1 to 10000){ b2.moveInto(b1) } }
  t1.join(); t2.join();
  println(s"b1 = ${b1.i}; b2 = ${b2.i}")
}

object DeadlockSolved extends App {
  val b1 = new BoxOk(50); val b2 = new BoxOk(100)
  val t1 = thread { for(i <- 1 to 10000){ b1.moveInto(b2) } }
  val t2 = thread { for(i <- 1 to 10000){ b2.moveInto(b1) } }
  t1.join(); t2.join();
  println(s"b1 = ${b1.i}; b2 = ${b2.i}") // But notice that result depends on ordering
}

object SynchronizedPoolBad extends App {
  private val tasks = scala.collection.mutable.Queue[() => Unit]()
  def asynchronous(body: =>Unit) = tasks.synchronized { tasks.enqueue(() => body) }
  val worker = new Thread {
    def poll(): Option[() => Unit] = tasks.synchronized {
      if (tasks.nonEmpty) Some(tasks.dequeue()) else None
    }
    override def run() = while (true) poll() match {
      case Some(task) => task(); case None =>
    } // BUSY WAITING!!!
  }
  worker.setDaemon(true) // JVM terminates when all non-daemon threads terminate
  worker.start()
  asynchronous { print("!") }
  asynchronous { print("?")}
  Thread.sleep(2000)
}

object SynchronizedGuardedBlocks extends App {
  val lock = new AnyRef
  var message: Option[String] = None
  val greeter = thread { lock.synchronized {
      while (message == None) lock.wait(); println(message.get)
  } }
  lock.synchronized { message = Some("Hello!"); lock.notify() }
  greeter.join()
}

object SynchronizedPoolOk extends App {
  private val tasks = scala.collection.mutable.Queue[() => Unit]()
  def asynchronous(body: =>Unit) = tasks.synchronized { tasks.enqueue(() => body); tasks.notify() }
  val worker = new Thread {
    def poll(): () => Unit = tasks.synchronized {
      while (tasks.isEmpty) tasks.wait()
      tasks.dequeue()
    }
    override def run() = while (true) poll() match {
      case task => task()
    } // BUSY WAITING!!!
  }
  worker.setDaemon(true) // JVM terminates when all non-daemon threads terminate
  worker.start()
  asynchronous { print("!") }
  asynchronous { print("?")}
  Thread.sleep(20000)
}

object GracefulShutdownExample extends App {
  private val tasks = scala.collection.mutable.Queue[() => Unit]()
  def asynchronous(body: =>Unit) = tasks.synchronized { tasks.enqueue(() => body); tasks.notify() }

  object Worker extends Thread {
    var terminated = false

    def poll(): Option[() => Unit] = tasks.synchronized {
      while (tasks.isEmpty && !terminated) tasks.wait()
      if (!terminated) Some(tasks.dequeue()) else None
    }

    @scala.annotation.tailrec override def run() = poll() match {
      case Some(task) => task(); run()
      case None => println("Bye bye")
    }

    def shutdown() = tasks.synchronized { terminated = true; tasks.notify() }
  }

  Worker.start()

  asynchronous{ println("Hello") }

  Thread.sleep(1000)
  Worker.shutdown()
  Thread.sleep(1000)
}