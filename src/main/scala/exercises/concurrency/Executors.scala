/*
 * This Scala source file was generated by the Gradle 'init' task.
 */
package exercises.concurrency

import java.util.concurrent.{Executor, ExecutorService, ForkJoinPool, TimeUnit}

import scala.concurrent.ExecutionContext

object Executor1 extends App {
  val executor: Executor = new ForkJoinPool
  executor.execute(new Runnable {
    def run() = println("This task is run asynchronously.")
  })
  Thread.sleep(500) // prevents daemon threads to terminate before they call run
}

object Executor2 extends App {
  val executor: ExecutorService = new ForkJoinPool
  executor.execute(new Runnable {
    def run() = println("This task is run asynchronously.")
  })
  executor.shutdown()
  executor.awaitTermination(1, TimeUnit.SECONDS)
}

object Executor3 extends App {
  val exec: ExecutionContext = ExecutionContext.fromExecutor(new ForkJoinPool())
  exec.execute(() => println("Hello"))
  Thread.sleep(1000)
}

object ExecUtils {
  def exec(b: => Unit) = ExecutionContext.global.execute(() => b)
}

import ExecUtils.exec

object Executor4 extends App {
  for(i <- 1 to 50) exec { Thread.sleep(1000); println(s"[${Thread.currentThread().getName}] Task $i completed") }
  Thread.sleep(10000)
}